# Абстрактная фабрика (Abstract Factory)
**Цель:**
Создание интерфейса, для создания множества взаимосвязанных или взаимозависимых объектов, без жёсткой
привязке к конкретным классам.

**Для чего используется:**
Для создания множеств взаимосвязанных объектов.

**Пример использования:**
- система не должна зависеть от метода создания, компоновки и представления входящих в неё объектов;
- входящие взаимосвязанные объекты должны использоваться вместе;
- система должна конфигурироваться одним из множеств объектов, из которых она состоит;
- нам необходимо предоставить множество объектов, раскрывая только их интерфейсы но не реализацию.

# Фабрика (Factory Method)
**Цель:**
Создание интерфейса, который создаёт объект. При этом, выбор того, экземпляр какого класса создавать
остаётся за классами, которые имплементируют данный интерфейс.

**Для чего используется:**
Для делигирования создания экземпляров, другому классу.

**Пример использования:**
- заранее неизвестно, экземпляры, какого класса нужно будет создавать;
- класс спроектирован таким образом, что создаваемые им объекты имеют свойства определённого класса.

# Строитель (Builder)
**Цель:**
Отделить конструирование сложного объекта от его представления таким образом, чтобы в результате одного 
и того же конструирования мы могли получить разные представления.

**Для чего используется**:
Для создания различных объектов из одного набора данных.

**Пример использования:**
- порядок создания сложного объекта не должен зависеть от того, из каких частей состоит объект и того, 
  как эти объекты взаимосвязаны;
- процесс констрирования объекта должен предоставлять различные представления, которые мы конструируем.

# Прототип (Protoctype)
**Цель:**
Определить вид создаваемых объектов с помощью экземпляра - прототипа и создавать новые объекты, 
копирую этот прототип.

**Для чего используется:**
Для создания копий заданого объекта.

**Пример использования:**
- классы экземпляры которых необходимо создавать определяются во время выполнения программы;
- для избежания построения иерархии классов, фабрик или пералельных иерархий классов;
- экземпляры класса могут находится в одном из немногих возможных состояний.

# Одиночка (Singleton)
**Цель:**
Гарантировать, что у класса будет только один единственный экземпляр и к нему 
будет представлена глобальная точка доступа.

**Для чего используется:**
Для создания единственного экземпляра определенного класса.

**Пример использования:**
- необходим только один экземпляр конкретного класса, который дуступен для всех клиентов;
- единственный экземпляр должен наследоваться путем порождения подклассов, при этом, клиенты 
имеют возможность работать с классом-наследником без модификации своего кода.

# Адаптер (Adapter)
**Цель:**
Преобразование интерфейса одного класса в интерфейс того класса, класса, который необходим клиенту

**Для чего используется:**
Для обеспечения совместной работы классов, интерфейсы которых не совместимы.

**Пример использования:**
- интерфейс класса, который мы хотим использовать не соответствует нашим потребностям;
- необходим класс, который должен взаимодействовать с классами, которые ему неизвестны 
  или не связаны с ним;
- необходимо использовать несколько существующих подклассов, но нецелесообразно использовать
  методы их классов создавая их новые подклассы.

# Мост (Bridge)
**Цель:**
Отделить абстракцию от её реализации таким образом, чтобы мы могли изменять независимо друг от друга
и то и другое.

**Для чего используется:**
Для получения преимуществ наследования без потери гибкости.

**Пример использования:**
- предотвращение жесткой привязки абстракции к реализации (например, реализацию необходимо 
  выбрать во время выполнения программы);
- в будущем мы хотим расширять с помощью подклассов и реализацию и абстракцию;
- если изменения в реализации не должны отражаться на клиентских абстракций;
- для разделения одной реализации между несколькими объектами и не показывать это клиенту.

# Компоновщик (Composite)
**Цель:**
Скомпонировать объекты в структуры по типу "дерева", позволяя клиентам единообразно трактовать 
отдельные и составные объекты.

**Для чего используется:**
Для группировки мелких компонентов в более крупные, которые, в свою очередь, могут стать 
основой для более крупных структур.

**Пример использования:**
- для представления иерархии "часть-целое";
- мы хотим, чтобы клиенты одним способом трактовали как отдельные, так и составные объекты.

# Декоратор (Decorator)
**Цель:**
Динамическое добавление новых обязанностей объекту.

**Для чего используется:**
В качестве альтернативы порождению подклассов для рассширения функциональности.

**Пример использования:**
- динамическое и понятное клиентам добавление обязаностей объектам;
- реализация обязанностей, которые могут быть сняты с объекта;
- рассширение класса путем порождения подклассов невозможно по каким-либо причинам.

# Фасад (Facade)
**Цель:**
Предоставить унифицированный интерфейс вместо нескольких интерфейсов системы.

**Для чего используется:**
Используется для определения интерфейса высокого уровня, который упрощает использование подсистемы.

**Пример использования:**
- изолирование клиентов от компонентов подсистемы, упрощая работу с ней;
- необходимость ослабления связанности подсистемы с клиентами.

# Приспособленец (Flyweight)
**Цель:**
Поддержка множества мелких объектов

**Для чего используется:**
Использует разделение для того, чтобы поддерживать много мелких объектов.

**Пример использования:**
- когда используется большое количество объектов;
- большую часть состояния объектов можно вынести наружу;
- приложение не зависит от идентичности объекта.

# Прокси (Proxy)
**Цель:**
Для замещения другого объекта и контроля доступа к нему.

**Для чего используется:**
Для обеспечения контроля доступа к определенному объекту.

**Пример использования:**
- когда есть необходимость ссылаться на объект способом отличным от обычного указателя;
- локальный представитель вместо объекта в другом адресном пространстве (удаленное замещение);
- создание "тяжёлых объектов" при необходимости (виртуальное замещение);
- контроль доступа к указаному объекту (защещённое замещение);
- замена обычного указателя: подсчет числа ссылок, установка блокировки и т.д. ("умная ссылка").

# Цепочка ответственности (Chain Of Responsibility)
**Цель:**
Связывание объектов - получателей в чепоччку и парадача запроса по ней.

**Для чего используется:**
Помогает избежать привязки отправителя запроса к его получателю, что дает обработать данный запрос нескольким объектам.

**Пример использования:**
- ослабление привязаности (объект не должен знать, кто именно обработает его запрос);
- дополнительная гипкость при рапределении дополнительных обязанностей между объектами.

# Команда (Command)
**Цель:**
Инкапсилирование запроса в объект.

**Для чего используется:**
Чтоба задать параматры клиентов для обработки определенных запросов, создание очереди из этих запросов или их контроля и
поддержки отмены операций.

**Пример использования:**
- параметризация объектов выполняемым действием;
- определять запрос, ставить его в очередь или выполнять его в разное время.

# Интерпретатор (Interpreter)
**Цель:**
Определение представления грамматики объекта.

**Для чего используется:**
Используется для определения представления грамматики заданого языка и интерпритации его предложений.

**Пример использования:**
- упрощение иерархии классов с помощью интерпретирования.

# Итератор (Iterator)
**Цель:**
Получение последовательного доступа ко всем элементам составного объекта.

**Для чего используется:**
Для получения последовательного доступа ко всем элементам составного объекта, скрывая его внутреннее представление.

**Пример использования:**
- различные виды обхода составного объектаж
- упрощенный доступ к составному объекту.
